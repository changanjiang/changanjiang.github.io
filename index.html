<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-portainer搭建" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/04/portainer%E6%90%AD%E5%BB%BA/" class="article-date">
  <time class="dt-published" datetime="2021-02-04T09:31:31.000Z" itemprop="datePublished">2021-02-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/04/portainer%E6%90%AD%E5%BB%BA/">portainer搭建</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="假设有了docker-环境"><a href="#假设有了docker-环境" class="headerlink" title="假设有了docker 环境"></a>假设有了docker 环境</h3><ul>
<li>首先拉取镜像 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull docker.io&#x2F;portainer&#x2F;portainer</span><br></pre></td></tr></table></figure></li>
<li>开启docker的远程管理<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;dockerd -H unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock -H tcp:&#x2F;&#x2F;0.0.0.0:2375</span><br></pre></td></tr></table></figure></li>
<li>重新加载配置重启docker<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload </span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure></li>
<li>检查防火墙状态-关闭防火墙<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl status firewalld</span><br><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure></li>
<li>启动容器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 14001:9000 --restart&#x3D;always -v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock --name prtainer portainer&#x2F;portainer</span><br></pre></td></tr></table></figure></li>
<li>访问<a target="_blank" rel="noopener" href="http://ip:14001/%E7%99%BB%E5%BD%95">http://ip:14001/登录</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/04/portainer%E6%90%AD%E5%BB%BA/" data-id="ckkqnz3nt00063wqk1r4q7343" data-title="portainer搭建" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-py操作MongoDB" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/04/py%E6%93%8D%E4%BD%9CMongoDB/" class="article-date">
  <time class="dt-published" datetime="2021-02-04T09:28:43.000Z" itemprop="datePublished">2021-02-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/04/py%E6%93%8D%E4%BD%9CMongoDB/">py操作MongoDB</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>MongoDB是由C++语言编写的非关系型数据库，是一个基于分布式文件存储的开源数据库系统，其内容存储形式类似JSON对象，它的字段值可以包含其他文档、数组及文档数组，非常灵活。在这一节中，我们就来看看Python 3下MongoDB的存储操作。</p>
<p><strong>1. 准备工作</strong></p>
<p>在开始之前，请确保已经安装好了MongoDB并启动了其服务，并且安装好了Python的PyMongo库。</p>
<p><strong>2. 连接MongoDB</strong></p>
<p>连接MongoDB时，我们需要使用PyMongo库里面的MongoClient。一般来说，传入MongoDB的IP及端口即可，其中第一个参数为地址host，第二个参数为端口port（如果不给它传递参数，默认是27017）：</p>
<p>import pymongo client = pymongo.MongoClient(host=’localhost’, port=27017)复制代码</p>
<p>这样就可以创建MongoDB的连接对象了。</p>
<p>另外，MongoClient的第一个参数host还可以直接传入MongoDB的连接字符串，它以mongodb开头，例如：</p>
<p>client = MongoClient(‘mongodb://localhost:27017/‘)复制代码</p>
<p>这也可以达到同样的连接效果。</p>
<p><strong>3. 指定数据库</strong></p>
<p>MongoDB中可以建立多个数据库，接下来我们需要指定操作哪个数据库。这里我们以test数据库为例来说明，下一步需要在程序中指定要使用的数据库：</p>
<p>db = client.test复制代码</p>
<p>这里调用client的test属性即可返回test数据库。当然，我们也可以这样指定：</p>
<p>db = client[‘test’]复制代码</p>
<p>这两种方式是等价的。</p>
<p><strong>4. 指定集合</strong></p>
<p>MongoDB的每个数据库又包含许多集合（collection），它们类似于关系型数据库中的表。</p>
<p>下一步需要指定要操作的集合，这里指定一个集合名称为students。与指定数据库类似，指定集合也有两种方式：</p>
<p>collection = db.students复制代码</p>
<p>collection = db[‘students’]复制代码</p>
<p>这样我们便声明了一个Collection对象。</p>
<p><strong>5. 插入数据</strong></p>
<p>接下来，便可以插入数据了。对于students这个集合，新建一条学生数据，这条数据以字典形式表示：</p>
<p>student = {    ‘id’: ‘20170101’,    ‘name’: ‘Jordan’,    ‘age’: 20,    ‘gender’: ‘male’ }复制代码</p>
<p>这里指定了学生的学号、姓名、年龄和性别。接下来，直接调用collection的insert()方法即可插入数据，代码如下：</p>
<p>result = collection.insert(student) print(result)复制代码</p>
<p>在MongoDB中，每条数据其实都有一个_id属性来唯一标识。如果没有显式指明该属性，MongoDB会自动产生一个ObjectId类型的_id属性。insert()方法会在执行后返回_id值。</p>
<p>运行结果如下：</p>
<p>5932a68615c2606814c91f3d复制代码</p>
<p>当然，我们也可以同时插入多条数据，只需要以列表形式传递即可，示例如下：</p>
<p>student1 = {    ‘id’: ‘20170101’,    ‘name’: ‘Jordan’,    ‘age’: 20,    ‘gender’: ‘male’ } student2 = {    ‘id’: ‘20170202’,    ‘name’: ‘Mike’,    ‘age’: 21,    ‘gender’: ‘male’ } result = collection.insert([student1, student2]) print(result)复制代码</p>
<p>返回结果是对应的_id的集合：</p>
<p>[ObjectId(‘5932a80115c2606a59e8a048’), ObjectId(‘5932a80115c2606a59e8a049’)]复制代码</p>
<p>实际上，在PyMongo 3.x版本中，官方已经不推荐使用insert()方法了。当然，继续使用也没有什么问题。官方推荐使用insert_one()和insert_many()方法来分别插入单条记录和多条记录，示例如下：</p>
<p>student = {    ‘id’: ‘20170101’,    ‘name’: ‘Jordan’,    ‘age’: 20,    ‘gender’: ‘male’ } result = collection.insert_one(student) print(result) print(result.inserted_id)复制代码</p>
<p>运行结果如下：</p>
<p>&lt;pymongo.results.InsertOneResult object at 0x10d68b558&gt; 5932ab0f15c2606f0c1cf6c5复制代码</p>
<p>与insert()方法不同，这次返回的是InsertOneResult对象，我们可以调用其inserted_id属性获取_id。</p>
<p>对于insert_many()方法，我们可以将数据以列表形式传递，示例如下：</p>
<p>student1 = {    ‘id’: ‘20170101’,    ‘name’: ‘Jordan’,    ‘age’: 20,    ‘gender’: ‘male’ } student2 = {    ‘id’: ‘20170202’,    ‘name’: ‘Mike’,    ‘age’: 21,    ‘gender’: ‘male’ } result = collection.insert_many([student1, student2]) print(result) print(result.inserted_ids)复制代码</p>
<p>运行结果如下：</p>
<p>&lt;pymongo.results.InsertManyResult object at 0x101dea558&gt; [ObjectId(‘5932abf415c2607083d3b2ac’), ObjectId(‘5932abf415c2607083d3b2ad’)]复制代码</p>
<p>该方法返回的类型是InsertManyResult，调用inserted_ids属性可以获取插入数据的_id列表。</p>
<p><strong>6. 查询</strong></p>
<p>插入数据后，我们可以利用find_one()或find()方法进行查询，其中find_one()查询得到的是单个结果，find()则返回一个生成器对象。示例如下：</p>
<p>result = collection.find_one({‘name’: ‘Mike’}) print(type(result)) print(result)复制代码</p>
<p>这里我们查询name为Mike的数据，它的返回结果是字典类型，运行结果如下：</p>
<p>&lt;class ‘dict’&gt; {‘_id’: ObjectId(‘5932a80115c2606a59e8a049’), ‘id’: ‘20170202’, ‘name’: ‘Mike’, ‘age’: 21, ‘gender’: ‘male’}复制代码</p>
<p>可以发现，它多了_id属性，这就是MongoDB在插入过程中自动添加的。</p>
<p>此外，我们也可以根据ObjectId来查询，此时需要使用bson库里面的objectid：</p>
<p>from bson.objectid import ObjectId result = collection.find_one({‘_id’: ObjectId(‘593278c115c2602667ec6bae’)}) print(result)复制代码</p>
<p>其查询结果依然是字典类型，具体如下：</p>
<p>{‘_id’: ObjectId(‘593278c115c2602667ec6bae’), ‘id’: ‘20170101’, ‘name’: ‘Jordan’, ‘age’: 20, ‘gender’: ‘male’}复制代码</p>
<p>当然，如果查询结果不存在，则会返回None。</p>
<p>对于多条数据的查询，我们可以使用find()方法。例如，这里查找年龄为20的数据，示例如下：</p>
<p>results = collection.find({‘age’: 20}) print(results) <strong>for</strong> result <strong>in</strong> results:    print(result)复制代码</p>
<p>运行结果如下：</p>
<p>&lt;pymongo.cursor.Cursor object at 0x1032d5128&gt; {‘_id’: ObjectId(‘593278c115c2602667ec6bae’), ‘id’: ‘20170101’, ‘name’: ‘Jordan’, ‘age’: 20, ‘gender’: ‘male’} {‘_id’: ObjectId(‘593278c815c2602678bb2b8d’), ‘id’: ‘20170102’, ‘name’: ‘Kevin’, ‘age’: 20, ‘gender’: ‘male’} {‘_id’: ObjectId(‘593278d815c260269d7645a8’), ‘id’: ‘20170103’, ‘name’: ‘Harden’, ‘age’: 20, ‘gender’: ‘male’}复制代码</p>
<p>返回结果是Cursor类型，它相当于一个生成器，我们需要遍历取到所有的结果，其中每个结果都是字典类型。</p>
<p>如果要查询年龄大于20的数据，则写法如下：</p>
<p>results = collection.find({‘age’: {‘$gt’: 20}})复制代码</p>
<p>这里查询的条件键值已经不是单纯的数字了，而是一个字典，其键名为比较符号$gt，意思是大于，键值为20。</p>
<p>这里将比较符号归纳为下表。</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>$lt</td>
<td>小于</td>
<td>{‘age’: {‘$lt’: 20}}</td>
</tr>
<tr>
<td>$gt</td>
<td>大于</td>
<td>{‘age’: {‘$gt’: 20}}</td>
</tr>
<tr>
<td>$lte</td>
<td>小于等于</td>
<td>{‘age’: {‘$lte’: 20}}</td>
</tr>
<tr>
<td>$gte</td>
<td>大于等于</td>
<td>{‘age’: {‘$gte’: 20}}</td>
</tr>
<tr>
<td>$ne</td>
<td>不等于</td>
<td>{‘age’: {‘$ne’: 20}}</td>
</tr>
<tr>
<td>$in</td>
<td>在范围内</td>
<td>{‘age’: {‘$in’: [20, 23]}}</td>
</tr>
<tr>
<td>$nin</td>
<td>不在范围内</td>
<td>{‘age’: {‘$nin’: [20, 23]}}</td>
</tr>
</tbody></table>
<p>另外，还可以进行正则匹配查询。例如，查询名字以M开头的学生数据，示例如下：</p>
<p>results = collection.find({‘name’: {‘$regex’: ‘^M.*’}})复制代码</p>
<p>这里使用$regex来指定正则匹配，^M.*代表以M开头的正则表达式。</p>
<p>这里将一些功能符号再归类为下表。</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
<th>示例</th>
<th>示例含义</th>
</tr>
</thead>
<tbody><tr>
<td>$regex</td>
<td>匹配正则表达式</td>
<td>{‘name’: {‘$regex’: ‘^M.*’}}</td>
<td>name以M开头</td>
</tr>
<tr>
<td>$exists</td>
<td>属性是否存在</td>
<td>{‘name’: {‘$exists’: True}}</td>
<td>name属性存在</td>
</tr>
<tr>
<td>$type</td>
<td>类型判断</td>
<td>{‘age’: {‘$type’: ‘int’}}</td>
<td>age的类型为int</td>
</tr>
<tr>
<td>$mod</td>
<td>数字模操作</td>
<td>{‘age’: {‘$mod’: [5, 0]}}</td>
<td>年龄模5余0</td>
</tr>
<tr>
<td>$text</td>
<td>文本查询</td>
<td>{‘$text’: {‘$search’: ‘Mike’}}</td>
<td>text类型的属性中包含Mike字符串</td>
</tr>
<tr>
<td>$where</td>
<td>高级条件查询</td>
<td>{‘$where’: ‘obj.fans_count == obj.follows_count’}</td>
<td>自身粉丝数等于关注数</td>
</tr>
</tbody></table>
<p>关于这些操作的更详细用法，可以在MongoDB官方文档找到：</p>
<p><a target="_blank" rel="noopener" href="https://docs.mongodb.com/manual/reference/operator/query/%E3%80%82">https://docs.mongodb.com/manual/reference/operator/query/。</a></p>
<p><strong>7. 计数</strong></p>
<p>要统计查询结果有多少条数据，可以调用count()方法。比如，统计所有数据条数：</p>
<p>count = collection.find().count() print(count)复制代码</p>
<p>或者统计符合某个条件的数据：</p>
<p>count = collection.find({‘age’: 20}).count() print(count)复制代码</p>
<p>运行结果是一个数值，即符合条件的数据条数。</p>
<p><strong>8. 排序</strong></p>
<p>排序时，直接调用sort()方法，并在其中传入排序的字段及升降序标志即可。示例如下：</p>
<p>results = collection.find().sort(‘name’, pymongo.ASCENDING) print([result[‘name’] <strong>for</strong> result <strong>in</strong> results])复制代码</p>
<p>运行结果如下：</p>
<p>[‘Harden’, ‘Jordan’, ‘Kevin’, ‘Mark’, ‘Mike’]复制代码</p>
<p>这里我们调用pymongo.ASCENDING指定升序。如果要降序排列，可以传入pymongo.DESCENDING。</p>
<p><strong>9. 偏移</strong></p>
<p>在某些情况下，我们可能想只取某几个元素，这时可以利用skip()方法偏移几个位置，比如偏移2，就忽略前两个元素，得到第三个及以后的元素：</p>
<p>results = collection.find().sort(‘name’, pymongo.ASCENDING).skip(2) print([result[‘name’] <strong>for</strong> result <strong>in</strong> results])复制代码</p>
<p>运行结果如下：</p>
<p>[‘Kevin’, ‘Mark’, ‘Mike’]复制代码</p>
<p>另外，还可以用limit()方法指定要取的结果个数，示例如下：</p>
<p>results = collection.find().sort(‘name’, pymongo.ASCENDING).skip(2).limit(2) print([result[‘name’] <strong>for</strong> result <strong>in</strong> results])复制代码</p>
<p>运行结果如下：</p>
<p>[‘Kevin’, ‘Mark’]复制代码</p>
<p>如果不使用limit()方法，原本会返回三个结果，加了限制后，会截取两个结果返回。</p>
<p>值得注意的是，在数据库数量非常庞大的时候，如千万、亿级别，最好不要使用大的偏移量来查询数据，因为这样很可能导致内存溢出。此时可以使用类似如下操作来查询：</p>
<p>from bson.objectid import ObjectId collection.find({‘_id’: {‘$gt’: ObjectId(‘593278c815c2602678bb2b8d’)}})复制代码</p>
<p>这时需要记录好上次查询的_id。</p>
<p><strong>10. 更新</strong></p>
<p>对于数据更新，我们可以使用update()方法，指定更新的条件和更新后的数据即可。例如：</p>
<p>condition = {‘name’: ‘Kevin’} student = collection.find_one(condition) student[‘age’] = 25 result = collection.update(condition, student) print(result)复制代码</p>
<p>这里我们要更新name为Kevin的数据的年龄：首先指定查询条件，然后将数据查询出来，修改年龄后调用update()方法将原条件和修改后的数据传入。</p>
<p>运行结果如下：</p>
<p>{‘ok’: 1, ‘nModified’: 1, ‘n’: 1, ‘updatedExisting’: True}复制代码</p>
<p>返回结果是字典形式，ok代表执行成功，nModified代表影响的数据条数。</p>
<p>另外，我们也可以使用$set操作符对数据进行更新，代码如下：</p>
<p>result = collection.update(condition, {‘$set’: student})复制代码</p>
<p>这样可以只更新student字典内存在的字段。如果原先还有其他字段，则不会更新，也不会删除。而如果不用$set的话，则会把之前的数据全部用student字典替换；如果原本存在其他字段，则会被删除。</p>
<p>另外，update()方法其实也是官方不推荐使用的方法。这里也分为update_one()方法和update_many()方法，用法更加严格，它们的第二个参数需要使用$类型操作符作为字典的键名，示例如下：</p>
<p>condition = {‘name’: ‘Kevin’} student = collection.find_one(condition) student[‘age’] = 26 result = collection.update_one(condition, {‘$set’: student}) print(result) print(result.matched_count, result.modified_count)复制代码</p>
<p>这里调用了update_one()方法，第二个参数不能再直接传入修改后的字典，而是需要使用{‘$set’: student}这样的形式，其返回结果是UpdateResult类型。然后分别调用matched_count和modified_count属性，可以获得匹配的数据条数和影响的数据条数。</p>
<p>运行结果如下：</p>
<p>&lt;pymongo.results.UpdateResult object at 0x10d17b678&gt; 1 0复制代码</p>
<p>我们再看一个例子：</p>
<p>condition = {‘age’: {‘$gt’: 20}} result = collection.update_one(condition, {‘$inc’: {‘age’: 1}}) print(result) print(result.matched_count, result.modified_count)复制代码</p>
<p>这里指定查询条件为年龄大于20，然后更新条件为{‘$inc’: {‘age’: 1}}，也就是年龄加1，执行之后会将第一条符合条件的数据年龄加1。</p>
<p>运行结果如下：</p>
<p>&lt;pymongo.results.UpdateResult object at 0x10b8874c8&gt; 1 1复制代码</p>
<p>可以看到匹配条数为1条，影响条数也为1条。</p>
<p>如果调用update_many()方法，则会将所有符合条件的数据都更新，示例如下：</p>
<p>condition = {‘age’: {‘$gt’: 20}} result = collection.update_many(condition, {‘$inc’: {‘age’: 1}}) print(result) print(result.matched_count, result.modified_count)复制代码</p>
<p>这时匹配条数就不再为1条了，运行结果如下：</p>
<p>&lt;pymongo.results.UpdateResult object at 0x10c6384c8&gt; 3 3复制代码</p>
<p>可以看到，这时所有匹配到的数据都会被更新。</p>
<p><strong>11. 删除</strong></p>
<p>删除操作比较简单，直接调用remove()方法指定删除的条件即可，此时符合条件的所有数据均会被删除。示例如下：</p>
<p>result = collection.remove({‘name’: ‘Kevin’}) print(result)复制代码</p>
<p>运行结果如下：</p>
<p>{‘ok’: 1, ‘n’: 1}复制代码</p>
<p>另外，这里依然存在两个新的推荐方法——delete_one()和delete_many()。示例如下：</p>
<p>result = collection.delete_one({‘name’: ‘Kevin’}) print(result) print(result.deleted_count) result = collection.delete_many({‘age’: {‘$lt’: 25}}) print(result.deleted_count)复制代码</p>
<p>运行结果如下：</p>
<p>&lt;pymongo.results.DeleteResult object at 0x10e6ba4c8&gt; 1 4复制代码</p>
<p>delete_one()即删除第一条符合条件的数据，delete_many()即删除所有符合条件的数据。它们的返回结果都是DeleteResult类型，可以调用deleted_count属性获取删除的数据条数。</p>
<p><strong>12. 其他操作</strong></p>
<p>另外，PyMongo还提供了一些组合方法，如find_one_and_delete()、find_one_and_replace()和find_one_and_update()，它们是查找后删除、替换和更新操作，其用法与上述方法基本一致。</p>
<p>另外，还可以对索引进行操作，相关方法有create_index()、create_indexes()和drop_index()等。</p>
<p>关于PyMongo的详细用法，可以参见官方文档：<a target="_blank" rel="noopener" href="http://api.mongodb.com/python/current/api/pymongo/collection.html%E3%80%82">http://api.mongodb.com/python/current/api/pymongo/collection.html。</a></p>
<p>另外，还有对数据库和集合本身等的一些操作，这里不再一一讲解，可以参见官方文档：<a target="_blank" rel="noopener" href="http://api.mongodb.com/python/current/api/pymongo/%E3%80%82">http://api.mongodb.com/python/current/api/pymongo/。</a></p>
<p>本节讲解了使用PyMongo操作MongoDB进行数据增删改查的方法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/04/py%E6%93%8D%E4%BD%9CMongoDB/" data-id="ckkqnz3nv00083wqk8vaxg42t" data-title="py操作MongoDB" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/py/" rel="tag">py</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Mongo与Mysql的一些事" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/04/Mongo%E4%B8%8EMysql%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B/" class="article-date">
  <time class="dt-published" datetime="2021-02-04T09:26:37.000Z" itemprop="datePublished">2021-02-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/04/Mongo%E4%B8%8EMysql%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B/">Mongo与Mysql的一些事</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Mongo db 与mysql 语法比较</p>
<p>传统的关系数据库一般由数据库（database）、表（table）、记录（record）三个层次概念组成，MongoDB是由数据库（database）、集合（collection）、文档对象（document）三个层次组成。MongoDB对于关系型数据库里的表，但是集合中没有列、行和关系概念，这体现了模式自由的特点。</p>
<table>
<thead>
<tr>
<th>MySQL</th>
<th>MongoDB</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>mysqld</td>
<td>mongod</td>
<td>服务器守护进程</td>
</tr>
<tr>
<td>mysql</td>
<td>mongo</td>
<td>客户端工具</td>
</tr>
<tr>
<td>mysqldump</td>
<td>mongodump</td>
<td>逻辑备份工具</td>
</tr>
<tr>
<td>mysql</td>
<td>mongorestore</td>
<td>逻辑恢复工具</td>
</tr>
<tr>
<td></td>
<td>db.repairDatabase()</td>
<td>修复数据库</td>
</tr>
<tr>
<td>mysqldump</td>
<td>mongoexport</td>
<td>数据导出工具</td>
</tr>
<tr>
<td>source</td>
<td>mongoimport</td>
<td>数据导入工具</td>
</tr>
<tr>
<td>grant * privileges on <em>.</em> to …</td>
<td>Db.addUser() Db.auth()</td>
<td>新建用户并权限</td>
</tr>
<tr>
<td>show databases</td>
<td>show dbs</td>
<td>显示库列表</td>
</tr>
<tr>
<td>Show tables</td>
<td>Show collections</td>
<td>显示表列表</td>
</tr>
<tr>
<td>Show slave status</td>
<td>Rs.status</td>
<td>查询主从状态</td>
</tr>
<tr>
<td>Create table users(a int, b int)</td>
<td>db.createCollection(“mycoll”, {capped:true,size:100000}) 另：mongo可隐式创建表。</td>
<td>创建表</td>
</tr>
<tr>
<td>Create INDEX idxname ON users(name)</td>
<td>db.users.ensureIndex({name:1})</td>
<td>创建索引</td>
</tr>
<tr>
<td>Create INDEX idxname ON users(name,ts DESC)</td>
<td>db.users.ensureIndex({name:1,ts:-1})</td>
<td>创建索引</td>
</tr>
<tr>
<td>Insert into users values(1, 1)</td>
<td>db.users.insert({a:1, b:1})</td>
<td>插入记录</td>
</tr>
<tr>
<td>Select a, b from users</td>
<td>db.users.find({},{a:1, b:1})</td>
<td>查询表</td>
</tr>
<tr>
<td>Select * from users</td>
<td>db.users.find()</td>
<td>查询表</td>
</tr>
<tr>
<td>Select * from users where age=33</td>
<td>db.users.find({age:33})</td>
<td>条件查询</td>
</tr>
<tr>
<td>Select a, b from users where age=33</td>
<td>db.users.find({age:33},{a:1, b:1})</td>
<td>条件查询</td>
</tr>
<tr>
<td>select * from users where age&lt;33</td>
<td>db.users.find({‘age’:{$lt:33}})</td>
<td>条件查询</td>
</tr>
<tr>
<td>select * from users where age&gt;33 and age&lt;=40</td>
<td>db.users.find({‘age’:{$gt:33,$lte:40}})</td>
<td>条件查询</td>
</tr>
<tr>
<td>select * from users where a=1 and b=’q’</td>
<td>db.users.find({a:1,b:’q’})</td>
<td>条件查询</td>
</tr>
<tr>
<td>select * from users where a=1 or b=2</td>
<td>db.users.find( { $or : [ { a : 1 } , { b : 2 } ] } )</td>
<td>条件查询</td>
</tr>
<tr>
<td>select * from users limit 1</td>
<td>db.users.findOne()</td>
<td>条件查询</td>
</tr>
<tr>
<td>select * from users where name like “%Joe%”</td>
<td>db.users.find({name:/Joe/})</td>
<td>模糊查询</td>
</tr>
<tr>
<td>select * from users where name like “Joe%”</td>
<td>db.users.find({name:/^Joe/})</td>
<td>模糊查询</td>
</tr>
<tr>
<td>select count(1) from users</td>
<td>Db.users.count()</td>
<td>获取表记录数</td>
</tr>
<tr>
<td>select count(1) from users where age&gt;30</td>
<td>db.users.find({age: {‘$gt’: 30}}).count()</td>
<td>获取表记录数</td>
</tr>
<tr>
<td>select DISTINCT last_name from users</td>
<td>db.users.distinct(‘last_name’)</td>
<td>去掉重复值</td>
</tr>
<tr>
<td>select * from users ORDER BY name</td>
<td>db.users.find().sort({name:-1})</td>
<td>排序</td>
</tr>
<tr>
<td>select * from users ORDER BY name DESC</td>
<td>db.users.find().sort({name:-1})</td>
<td>排序</td>
</tr>
<tr>
<td>EXPLAIN select * from users where z=3</td>
<td>db.users.find({z:3}).explain()</td>
<td>获取存储路径</td>
</tr>
<tr>
<td>update users set a=1 where b=’q’</td>
<td>db.users.update({b:’q’}, {$set:{a:1}}, false, true)</td>
<td>更新记录</td>
</tr>
<tr>
<td>update users set a=a+2 where b=’q’</td>
<td>db.users.update({b:’q’}, {$inc:{a:2}}, false, true)</td>
<td>更新记录</td>
</tr>
<tr>
<td>delete from users where z=”abc”</td>
<td>db.users.remove({z:’abc’})</td>
<td>删除记录</td>
</tr>
<tr>
<td></td>
<td>db. users.remove()</td>
<td>删除所有的记录</td>
</tr>
<tr>
<td>drop database IF EXISTS test;</td>
<td>use test db.dropDatabase()</td>
<td>删除数据库</td>
</tr>
<tr>
<td>drop table IF EXISTS test;</td>
<td>db.mytable.drop()</td>
<td>删除表/collection</td>
</tr>
<tr>
<td></td>
<td>db.addUser(‘test’, ‘test’)</td>
<td>添加用户 readOnly–&gt;false</td>
</tr>
<tr>
<td></td>
<td>db.addUser(‘test’, ‘test’, true)</td>
<td>添加用户 readOnly–&gt;true</td>
</tr>
<tr>
<td></td>
<td>db.addUser(“test”,”test222”)</td>
<td>更改密码</td>
</tr>
<tr>
<td></td>
<td>db.system.users.remove({user:”test”}) 或者 db.removeUser(‘test’)</td>
<td>删除用户</td>
</tr>
<tr>
<td></td>
<td>use admin</td>
<td>超级用户</td>
</tr>
<tr>
<td></td>
<td>db.auth(‘test’, ‘test’)</td>
<td>用户授权</td>
</tr>
<tr>
<td></td>
<td>db.system.users.find()</td>
<td>查看用户列表</td>
</tr>
<tr>
<td></td>
<td>show users</td>
<td>查看所有用户</td>
</tr>
<tr>
<td></td>
<td>db.printCollectionStats()</td>
<td>查看各collection的状态</td>
</tr>
<tr>
<td></td>
<td>db.printReplicationInfo()</td>
<td>查看主从复制状态</td>
</tr>
<tr>
<td></td>
<td>show profile</td>
<td>查看profiling</td>
</tr>
<tr>
<td></td>
<td>db.copyDatabase(‘mail_addr’,’mail_addr_tmp’)</td>
<td>拷贝数据库</td>
</tr>
<tr>
<td></td>
<td>db.users.dataSize()</td>
<td>查看collection数据的大小</td>
</tr>
<tr>
<td></td>
<td>db. users.totalIndexSize()</td>
<td>查询索引的大小</td>
</tr>
</tbody></table>
<p>db.getCollection(‘sp_ershoufang’).find({‘updateDate’:’2019-04-10’, ‘totalPrice’:{$gte:100,$lte:150}, ‘regions.district’:’龙岗’, ‘houseType’:{ $regex:’2室’, $options: ‘i’}}).sort({totalPrice:1, unitPrice:1})</p>
<p><strong>1.验证删除数据后用db.serverStatus().mem命令查看的</strong>磁盘空间<strong>占用是否变化</strong></p>
<p><strong>结论：删除collection内的数据不会释放磁盘空间；</strong></p>
<p><strong>可以采用db.runCommand({closeAllDatabases:1}):</strong></p>
<p>进入删除了数据的db,采用**db.repairDatabase()**：</p>
<p>mongodb语法</p>
<p>MongoDB的好处很多，比如多列索引，查询时可以用一些统计函数，支持多条件查询，但是目前多表查询是不支持的，可以想办法通过数据冗余来解决多表查询的问题。</p>
<p>MongoDB对数据的操作很丰富，下面做一些举例说明，内容大部分来自官方文档，另外有部分为自己理解。</p>
<p>查询colls所有数据</p>
<p>db.colls.find() //select * from colls</p>
<p>通过指定条件查询</p>
<p>db.colls.find({‘last_name’: ‘Smith’});//select * from colls where last_name=’Smith’</p>
<p>指定多条件查询</p>
<p>db.colls.find( { x : 3, y : “foo” } );//select * from colls where x=3 and y=’foo’</p>
<p>指定条件范围查询</p>
<p>db.colls.find({j: {$ne: 3}, k: {$gt: 10} });//select * from colls where j!=3 and k&gt;10</p>
<p>查询不包括某内容</p>
<p>db.colls.find({}, {a:0});//查询除a为0外的所有数据</p>
<p>支持&lt;, &lt;=, &gt;, &gt;=查询，需用符号替代分别为$lt，$lte，$gt，$gte</p>
<p>db.colls.find({ “field” : { $gt: value } } );</p>
<p>db.colls.find({ “field” : { $lt: value } } );</p>
<p>db.colls.find({ “field” : { $gte: value } } );</p>
<p>db.colls.find({ “field” : { $lte: value } } );</p>
<p>也可对某一字段做范围查询</p>
<p>db.colls.find({ “field” : { $gt: value1, $lt: value2 } } );</p>
<p>不等于查询用字符$ne</p>
<p>db.colls.find( { x : { $ne : 3 } } );</p>
<p>in查询用字符$in</p>
<p>db.colls.find( { “field” : { $in : array } } );</p>
<p>db.colls.find({j:{$in: [2,4,6]}});</p>
<p>not in查询用字符$nin</p>
<p>db.colls.find({j:{$nin: [2,4,6]}});</p>
<p>取模查询用字符$mod</p>
<p>db.colls.find( { a : { $mod : [ 10 , 1 ] } } )// where a % 10 == 1</p>
<p>$all查询</p>
<p>db.colls.find( { a: { $all: [ 2, 3 ] } } );//指定a满足数组中任意值时</p>
<p>$size查询</p>
<p>db.colls.find( { a : { $size: 1 } } );//对对象的数量查询，此查询查询a的子对象数目为1的记录</p>
<p>$exists查询</p>
<p>db.colls.find( { a : { $exists : true } } ); // 存在a对象的数据</p>
<p>db.colls.find( { a : { $exists : false } } ); // 不存在a对象的数据</p>
<p>$type查询$type值为bson<a target="_blank" rel="noopener" href="http://bsonspec.org/%E6%95%B0">http://bsonspec.org/数</a> 据的类型值</p>
<p>db.colls.find( { a : { $type : 2 } } ); // 匹配a为string类型数据</p>
<p>db.colls.find( { a : { $type : 16 } } ); // 匹配a为int类型数据</p>
<p>使用正则表达式匹配</p>
<p>db.colls.find( { name : /acme.*corp/i } );//类似于SQL中like</p>
<p>内嵌对象查询</p>
<p>db.colls.find( { “author.name” : “joe” } );</p>
<p>1.3.3版本及更高版本包含$not查询</p>
<p>db.colls.find( { name : { $not : /acme.*corp/i } } );</p>
<p>db.colls.find( { a : { $not : { $mod : [ 10 , 1 ] } } } );</p>
<p>sort()排序</p>
<p>db.colls.find().sort( { ts : -1 } );//1为升序2为降序</p>
<p>limit()对限制查询数据返回个数</p>
<p>db.colls.find().limit(10)</p>
<p>skip()跳过某些数据</p>
<p>db.colls.find().skip(10)</p>
<p>mongo更新一个字段为另一个字段的值</p>
<p>db.getCollection(‘house_2018-11-21’).find().forEach(</p>
<p>function(e) {</p>
<p>​         e.area = int(e.total_price*10000/ e.unit_price);</p>
<p>​         db.getCollection(‘house_2018-11-21’).save(e)</p>
<p>});</p>
<p><strong>group分组查询。</strong></p>
<p>参数说明：</p>
<ul>
<li>key：用来分组文档的字段。</li>
<li>initial: 每组都分享一个”初始化函数“</li>
<li>$reduce: 执行的reduce函数，第一个参数是当前的文档对象，第二个参数是上一次function操作的累计对象，有多少个文档， $reduce就会调用多少次。</li>
<li>condition：（可选）执行过滤的条件</li>
<li>finalize：（可选）在reduce执行完成，结果集返回之前对结果集最终执行的函数。</li>
</ul>
<p>例如，我们按年级分组，查出每个年级的学生姓名：</p>
<p>db.students.group({ key:{grade:true}, initial:{stuNames:[], count:0}, $reduce:function(cur, prev){ prev.stuNames.push(cur.name); } })</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/04/Mongo%E4%B8%8EMysql%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B/" data-id="ckkqnz3nq00033wqk5a479sy4" data-title="Mongo与Mysql的一些事" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Flex的布局使用" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/04/Flex%E7%9A%84%E5%B8%83%E5%B1%80%E4%BD%BF%E7%94%A8/" class="article-date">
  <time class="dt-published" datetime="2021-02-04T09:21:28.000Z" itemprop="datePublished">2021-02-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/04/Flex%E7%9A%84%E5%B8%83%E5%B1%80%E4%BD%BF%E7%94%A8/">Flex的布局使用</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Flex布局的学习"><a href="#Flex布局的学习" class="headerlink" title="Flex布局的学习"></a>Flex布局的学习</h2><ul>
<li>网页布局是CSS的一个重点应用</li>
<li>布局传统有很多种解决方法，常用的盒子模型,他们依赖display,position,float等,对于有一些特殊的布局不是很好解决,比如垂直居中…</li>
<li>Flex是诞生就是为了解决这些布局,它简洁、方便、完整，响应式地实现了各种页面布局。</li>
</ul>
<h2 id="Flex布局是什么"><a href="#Flex布局是什么" class="headerlink" title="Flex布局是什么"></a>Flex布局是什么</h2><ul>
<li>任何一个容器都可以指定为Flex布局,只要加上dispaly:flex<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispaly: flex;</span><br></pre></td></tr></table></figure></li>
<li>WebKit内核的浏览器,必须要加上-webkit前缀,也就是:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispalt: -webkit-flex;</span><br></pre></td></tr></table></figure></li>
<li>还有一点需要注意的,如果使用了flex布局,它的子元素的float、clear和vertical-align都将会失效</li>
</ul>
<h2 id="flex的基本概念"><a href="#flex的基本概念" class="headerlink" title="flex的基本概念"></a>flex的基本概念</h2><h3 id="flex容器的结构-flex容器存在两根轴-主-水平-轴和交叉-交叉-轴。"><a href="#flex容器的结构-flex容器存在两根轴-主-水平-轴和交叉-交叉-轴。" class="headerlink" title="flex容器的结构- flex容器存在两根轴,主(水平)轴和交叉(交叉)轴。"></a>flex容器的结构- flex容器存在两根轴,主(水平)轴和交叉(交叉)轴。</h3><h3 id="flex的属性"><a href="#flex的属性" class="headerlink" title="flex的属性:"></a>flex的属性:</h3><ul>
<li>flex有6个属性可以设置在容器上,分别是:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- flex-direction #决定了主轴的排列方向</span><br><span class="line">- flex-wrap #定义换行的方式</span><br><span class="line">- flex-flow #flex-direction和flex-warp的简写</span><br><span class="line">- justify-content #主轴的对齐方式</span><br><span class="line">- align-items #交叉轴的对齐方式</span><br><span class="line">- align-content #定义多根轴的对齐方式</span><br></pre></td></tr></table></figure></li>
<li>属性的值:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">flex-direction: row | row-reverse | column | column-reverse; </span><br><span class="line"># 分别是: 从左到右排序  从右到左排序  从上到下排序  从下到上排序</span><br><span class="line"></span><br><span class="line">flex-wrap:  nowrap | wrap | wrap-reverse;</span><br><span class="line"># 分别是: 不换行 换行的第一行在上方  换行的第一行在下方</span><br><span class="line"></span><br><span class="line">flex-flow: &lt;flex-direction&gt; | &lt;flex-wrap&gt;</span><br><span class="line"></span><br><span class="line">justify-content:flex-start | flex-end | center | space-between | space-around;</span><br><span class="line"># 分别是:左对齐  右对齐  居中  俩端对齐  项目之间的间隔相  每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍</span><br><span class="line"></span><br><span class="line">align-items:flex-start | flex-end | center | baseline | stretch;</span><br><span class="line"># 分别是: 交叉轴的起点对齐(上方)  交叉抽的终点对齐(下方)  居中对齐 容器的第一行文字的基线对齐  stretch(默认值),如果没有设置高度或者auto,那么容器会占满整个容器的高度</span><br><span class="line"></span><br><span class="line"> align-content:flex-start | flex-end | center | space-between | space-around | stretch; </span><br><span class="line"> #这个解释不来</span><br><span class="line"> </span><br></pre></td></tr></table></figure></li>
<li>项目的属性:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">order  定义容器的排列顺序,数值越小,排列越靠前,默认为0</span><br><span class="line">flex-grow 定义容器的放大比例,默认为0,即如果存在剩余空间,也不放大</span><br><span class="line">flex-shrink 定义了容器的缩小比例,默认为1,即如果空间不足,将自动缩小容器</span><br><span class="line">flex-basis 定义了在分配多余空间之前,容器占据的主轴空间,浏览器根据这个属性,计算主轴是否还有多余的空间.它的默认值是auto,即容器的本来大小</span><br><span class="line">flex  它是flex-grow,flex-shrink和flex-basis的简写,默认值为 0 1 auto</span><br><span class="line">align-self 定义了允许单个容器和其他容器有不一样的对齐方式,它可以覆盖align-items属性,默认值为auto,表示继承父元素的align-items属性,如果没有父元素,则等同于stretch。</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/04/Flex%E7%9A%84%E5%B8%83%E5%B1%80%E4%BD%BF%E7%94%A8/" data-id="ckkqnz3nk00013wqk77fh6alr" data-title="Flex的布局使用" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Flex/" rel="tag">Flex</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/css/" rel="tag">css</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li></ul>

    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flex/" rel="tag">Flex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/" rel="tag">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/py/" rel="tag">py</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Flex/" style="font-size: 10px;">Flex</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/py/" style="font-size: 10px;">py</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 10px;">前端</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 20px;">数据库</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/02/04/portainer%E6%90%AD%E5%BB%BA/">portainer搭建</a>
          </li>
        
          <li>
            <a href="/2021/02/04/py%E6%93%8D%E4%BD%9CMongoDB/">py操作MongoDB</a>
          </li>
        
          <li>
            <a href="/2021/02/04/Mongo%E4%B8%8EMysql%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B/">Mongo与Mysql的一些事</a>
          </li>
        
          <li>
            <a href="/2021/02/04/Flex%E7%9A%84%E5%B8%83%E5%B1%80%E4%BD%BF%E7%94%A8/">Flex的布局使用</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>